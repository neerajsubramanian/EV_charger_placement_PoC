"""
Utilities for finding appropriate flux bias offsets.
"""
from __future__ import division, absolute_import

import numpy as np

from scipy.optimize import curve_fit


__all__ = ['oneshot_flux_bias']


FLUX_BIAS_KWARG = 'flux_biases'


def oneshot_flux_bias(sampler, chains, flux_bias_list=None, num_reads=10000, target_J=None,
                      chain_strength=1, ignore_single_qubit_chains=False, **sampler_kwargs):
    """Calculates the flux biases needed to balance the chains provided.

    Args:
        sampler (:class:`dwave.system.samplers`):
            A dimod_ sampler. Normally :class:`dwave.system.samplers`, or a
            derived composite sampler. Other samplers in general will not work or will not make
            sense with this function.

        chains (list[iterable]):
            The chains. Each chain should be an iterable of nodes.

        flux_bias_list (list, optional, default=None):
            The flux biases to sweep. If None will sweep the values -2.5e-5 to 2.5e5 with step size
            1.0e-6.

        num_reads (int, optional, default=10000):
            The number of samplers to collect per flux bias value.

        target_J (dict, optional, default=None):
            The target (embedded) quadratic biases. If None, only the quadratic biases that induce
            the chains will be used.

        chain_strength (float, optional, default=1):
            The magnitude of the negative quadratic bias applied between variables within a chain.
            Only used when target_J=None.

        ignore_single_qubit_chains (bool, optional, default=False):
            If True, flux biases are not calculated for chains of length 1.

        Additional keyword arguments are passed directly to the given `sampler`.

    Returns:
        dict: A dict where the keys are the nodes in the chains and the values are the flux biases.

    """
    submitted_sweeps = submit_flux_bias_sweeps(sampler, chains, flux_bias_list, num_reads, target_J,
                                               chain_strength, **sampler_kwargs)
    return calculate_flux_biases(sampler, chains, submitted_sweeps,
                                 ignore_single_qubit_chains=ignore_single_qubit_chains)


def submit_flux_bias_sweeps(sampler, chains, flux_bias_list=None, num_reads=5000, target_J=None,
                            chain_strength=1, **sampler_kwargs):
    """Sweep the flux biases to get the information needed to determine the flux bias offsets.

    Args:
        sampler (:class:`dwave.system.samplers`):
            A dimod_ sampler. Normally :class:`dwave.system.samplers`, or a
            derived composite sampler. Other samplers in general will not work or will not make
            sense with this function.

        chains (list[iterable]):
            The chains. Each chain should be an iterable of nodes.

        flux_bias_list (list, optional, default=None):
            The flux biases to sweep. If None will sweep the values -2.5e-5 to 2.5e5 with step size
            .5e-6.

        num_reads (int, optional, default=10000):
            The number of samplers to collect per flux bias value.

        target_J (dict, optional, default=None):
            The target (embedded) quadratic biases. If None, only the quadratic biases that induce
            the chains will be used.

        chain_strength (float, optional, default=1):
            The magnitude of the negative quadratic bias applied between variables within a chain.
            Only used when target_J=None.

        Additional keyword arguments are passed directly to the given `sampler`.

    Returns:
        dict[float, :class:`dimod.Response`]: The submitted sweeps. The keys are the flux bias
        offsets from `flux_bias_list`, the values are the responses from the sampler.

    .. _dimod: https://github.com/dwavesystems/dimod

    """
    if not isinstance(chains, list):
        chains = list(chains)

    # we are interested only in the nodes that exist in some chain
    chain_nodes = set().union(*chains)

    try:
        nodelist, __, adj = sampler.structure
    except (AttributeError, ValueError):
        raise ValueError("sampler is not structured or has an unexpected structure.")

    if FLUX_BIAS_KWARG not in sampler.parameters:
        raise ValueError("sampler does not accept a '%s' kwarg" % FLUX_BIAS_KWARG)

    if 'num_reads' not in sampler.parameters:
        raise ValueError("sampler does not accept a 'num_reads' kwarg")

    if 'num_qubits' in sampler.properties:
        num_qubits = sampler.properties['num_qubits']
    else:
        raise ValueError("sampler does not have a 'num_qubits' property")

    # prep input parameters
    if flux_bias_list is None:
        flux_bias_list = np.round(np.arange(-2.5e-5, 2.5e-5, 1.0e-6), 8)
    else:
        if not isinstance(flux_bias_list, list):
            flux_bias_list = list(flux_bias_list)  # iterables are okay but not preferred

            # some additional checks could be performed here

    if target_J is None:
        # if none, just set all of the inter-chain quadratic biases to -chain_strength
        target_J = {}
        for chain in chains:
            target_J.update(_chain_to_quadratic(chain, adj, chain_strength))

    # include in h all of the nodes mentioned in chains or in target_J
    target_h = {v: 0.0 for v in set().union(*chains).union(*target_J)}

    if 'auto_scale' in sampler.parameters:
        sampler_kwargs['auto_scale'] = False

    # we need to pause slightly between submissions because they can be so large they can
    # overwhelm the server
    import time

    # async submit problems
    submitted_sweeps = {}
    for flux_bias_magnitude in flux_bias_list:
        sampler_kwargs[FLUX_BIAS_KWARG] = [flux_bias_magnitude if v in chain_nodes else 0.
                                           for v in range(num_qubits)]
        submitted_sweeps[flux_bias_magnitude] = sampler.sample_ising(target_h, target_J,
                                                                     num_reads=num_reads,
                                                                     **sampler_kwargs)

        time.sleep(.025)

    return submitted_sweeps


def calculate_flux_biases(sampler, chains, submitted_sweeps, ignore_single_qubit_chains=False):
    """Analyze the sweeps submitted by `submit_flux_bias_sweeps` to determine the flux bias offsets.

    Args:
        sampler (:class:`dwave.system.samplers`):
            A dimod_ sampler. Normally :class:`dwave.system.samplers.DWaveSampler`, or a
            derived composite sampler. Other samplers in general will not work or will not make
            sense with this function.

        chains (list[iterable]):
            The chains. Each chain should be an iterable of nodes. Should match the chains given to
            :func:`submit_flux_bias_sweeps`.

        submitted_sweeps (dict):
            As returned by :func:`submit_flux_bias_sweeps`.

        ignore_single_qubit_chains (bool, optional, default=False):
            If True, flux biases are not calculated for chains of length 1.

    Returns:
        dict: A dict where the keys are the nodes in the chains and the values are the flux biases.

    """
    if not isinstance(chains, list):
        chains = list(chains)  # we need chains to be ordered

    flux_bias_magnitudes = list(submitted_sweeps)  # all of the flux bias offset magnitudes swept

    # iterate through the responses, getting the ratio of spin-up/spin-down
    chain_averages = [{} for __ in chains]  # linked by index to chains

    for fbo in flux_bias_magnitudes:
        response = submitted_sweeps[fbo]

        for averages, chain in zip(chain_averages, chains):
            averages[fbo] = chain_average(chain, response)

        del submitted_sweeps[fbo]
        del response  # try to clear the future

    min_fbo = min(flux_bias_magnitudes)
    max_fbo = max(flux_bias_magnitudes)

    flux_biases = {}

    # now analyze them
    for averages, chain in zip(chain_averages, chains):

        if ignore_single_qubit_chains and len(chain) == 1:
            continue

        xx = flux_bias_magnitudes
        yy = [averages[fb] for fb in xx]
        slope, intercept = fit_sigmoid_to_spin_expectation(xx, yy, min_intercept=min_fbo, max_intercept=max_fbo)

        if np.isclose(intercept, 0., rtol=1e-10, atol=1e-10):
            continue

        for v in chain:
            flux_biases[v] = intercept

    return flux_biases


def chain_average(chain, response):
    """Determine the average value for the chain over the entire response.

    Ignores broken chains.

    Args:
        chain (iterable):
            A collection of variables that form a chain.

        response (:class:`dimod.Response`):
            A response from a dimod_ sampler.

    Returns:
        float: The average value for the chain over all of the samples.

    Raises:
        ValueError: If the response is empty or all the chains are broken.

    .. _dimod: https://github.com/dwavesystems/dimod

    """
    if not response:
        raise ValueError("the response is empty or all the chains are broken")

    columns = [response.variables.index(v) for v in chain]

    samples = response.record.sample

    return float(samples[:, columns].mean(axis=1).mean())


def sigmoid(x, intercept, slope):
    """Sigmoid function with given x-intercept and slope at x-intercept.

    Returns:
        :class:`~numpy.ndarray`: tanh(slope * (x - intercept))

    """
    return np.tanh(slope * (x - intercept))


def fit_sigmoid_to_spin_expectation(xdata, ydata, min_intercept=-2.5e-5, max_intercept=2.5e-5):
    """Fit a sigmoid to spin expectation as a function of a swept parameter.

    Let y = tanh(slope * (x - intercept))

    Args:
        xdata (iterable):
            The independent variable where the data is measured (an array of x values).

        ydata (iterable):
            The dependent data (an array of y values)

        min_intercept (Number, optional, default=-2.5e-5):
            The lower bound for the intercept.

        max_intercept (Number, optional, default=2.5e-5):
            The upper bound for the intercept.

    Returns:
        tuple: A 2-tuple:

            float: The slope of a sigmoid fit to xdata, ydata

            float: The intercept of the sigmoid fit to xdata ydata

    """
    mask = np.flatnonzero(np.isfinite(xdata) & np.isfinite(ydata))

    bounds = (np.array([min_intercept, -np.inf]), np.array([max_intercept, np.inf]))

    try:
        (intercept, slope), _ = curve_fit(sigmoid, np.array(xdata)[mask], np.array(ydata)[mask], p0=(0., 1.),
                                          bounds=bounds)
    except RuntimeError:
        # if the least-squares minimization fails.
        return 0.0, 0.0

    return slope, intercept


def _chain_to_quadratic(chain, target_adjacency, chain_strength):
    """Determine the quadratic biases that induce the given chain.

    Args:
        chain (iterable):
            The variables that make up a chain.

        target_adjacency (dict/:class:`networkx.Graph`):
            Should be a dict of the form {s: Ns, ...} where s is a variable
            in the target graph and Ns is the set of neighbours of s.

        chain_strength (float):
            The magnitude of the quadratic bias that should be used to create chains.

    Returns:
        dict[edge, float]: The quadratic biases that induce the given chain.

    Raises:
        ValueError: If the variables in chain do not form a connected subgraph of target.

    Examples:
        >>> chain = {1, 2}
        >>> target_adjacency = {0: {1, 2}, 1: {0, 2}, 2: {0, 1}}
        >>> dimod.embedding.chain_to_quadratic(chain, target_adjacency, 1)
        {(1, 2): -1}

    """
    quadratic = {}  # we will be adding the edges that make the chain here

    # do a breadth first search
    seen = set()
    try:
        next_level = {next(iter(chain))}
    except StopIteration:
        raise ValueError("chain must have at least one variable")
    while next_level:
        this_level = next_level
        next_level = set()
        for v in this_level:
            if v not in seen:
                seen.add(v)

                for u in target_adjacency[v]:
                    if u not in chain:
                        continue
                    next_level.add(u)
                    if u != v and (u, v) not in quadratic:
                        quadratic[(v, u)] = -chain_strength

    if len(chain) != len(seen):
        raise ValueError('{} is not a connected chain'.format(chain))

    return quadratic
